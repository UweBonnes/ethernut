/*
 * $Log: nutdoc_en.txt,v $
 * Revision 1.5  2005/02/06 16:37:54  haraldkipp
 * FTP sample added
 *
 * Revision 1.4  2004/09/12 09:10:04  haraldkipp
 * Version 3.9, old stuff removed
 *
 * Revision 1.3  2004/08/11 22:21:53  freckle
 * Some docu added for mutex, semaphore and the unix emulation
 *
 * Revision 1.2  2003/12/19 22:34:35  drsung
 * Added xgCrtTime for time functions
 *
 * Revision 1.1  2003/12/15 19:41:08  haraldkipp
 * First check in
 *
 * Revision 1.10  2003/05/06 19:01:49  harald
 * Prepare final release
 *
 * Revision 1.9  2003/03/31 14:53:21  harald
 * Prepare release 3.1
 *
 * Revision 1.8  2003/01/14 17:12:13  harald
 * Release 2.6.0
 *
 * Revision 1.7  2002/11/05 17:50:48  harald
 * *** empty log message ***
 *
 * Revision 1.6  2002/10/31 16:06:36  harald
 * Prerelease 2.5.9
 *
 * Revision 1.5  2002/09/15 17:11:42  harald
 * Release 2.5.2
 *
 * Revision 1.4  2002/09/03 17:48:10  harald
 * Release 2.5.1
 *
 * Revision 1.3  2002/08/16 17:50:12  harald
 * Release 2.5
 *
 * Revision 1.2  2002/08/11 12:28:42  harald
 * Using hex file extension now
 *
 * Revision 1.1  2002/08/02 14:02:37  harald
 * First check in
 *
 */
/*!
 * \mainpage Nut Operating System And TCP/IP Stack
 *
 * \image html logo_ethernut_239x57.gif
 *
 *
 * \section intro Introduction
 *
 * This is a preview of the upcoming version 4.
 *
 * For latest information please visit
 * http://www.ethernut.de/en/nutconf/index.html
 *
 * ImageCraft users will find additional information at
 * http://www.ethernut.de/en/iccavr/index.html
 *
 *
 * Ethernut is an Open Source Hardware and Software Project for building 
 * Embedded Ethernet Devices.
 *
 * The hardware design includes a small board, which is equipped with an 
 * Atmel ATmega128 CPU and a Realtek RTL8019AS or SMSC LAN91C111 Ethernet 
 * Controller.
 *
 * The software part is based on an Open Source implementation of a Real 
 * Time Operating System called Nut/OS and a TCP/IP protocol suite named 
 * Nut/Net.
 *
 * This document is intended as a programmer's reference to the
 * Nut/OS and Nut/Net API. It has been generated from the source 
 * code by Doxygen, a great tool created by Dimitri van Heesch.
 *
 * As a first step, you may want to set up your 
 * \ref compiler "Compiler Environment".
 *
 * \subsection contact Contact Information
 * If you would like to contact us regarding Ethernut, please email
 * info@egnite.de
 *
 * For updated information you may regularly visit
 * http://www.ethernut.de/
 */

/*!
 * \page compiler Setting the Compiler Environment
 *
 * This section is not up to date. Please visit
 * http://www.ethernut.de/en/nutconf/index.html
 *
 * ImageCraft users will find more information at
 * http://www.ethernut.de/en/iccavr/index.html
 *
 *
 *
 * The first decision that has to be made, is to select the development 
 * platform you want to use. The commercial ImageCraft Compiler offers 
 * an advanced IDE and is the first choice of most professional developers 
 * using a Windows PC. The GNU compiler AVR-GCC is available for Linux 
 * and Windows (WinAVR).
 *
 * \li Open a command line window.
 * \li Change to the Nut/OS installation directory.
 * \li Make sure, that your compiler's bin directory is include in the PATH.
 * \li Execute configure or nutconf (see below).
 *
 * In order to start with your own Embedded Ethernet Application, take 
 * one of the samples like TCPS and add some modifications. Then recompile 
 * and link it with the Nut/OS library by using the prepared Makefile 
 * for the GNU compiler or simply press the "Build" button of the ImageCraft 
 * IDE. The ImageCraft IDE comes with an integrated tool to upload the 
 * resulting binary into your Ethernut Board. The GNU archive provides a 
 * command line utility named usip, which takes over this task. Also note, 
 * that Ethernut applications are linked to the Nut/OS operating system and 
 * its TCP/IP Stack. The resulting binary file contains all three parts, 
 * the application, Nut/OS and Nut/Net. The advantage is, that only those 
 * parts of the operating system are included, which your application 
 * really needs, leaving more room for application code.
 *
 * The next chapters will provide more detailed instructions.
 *
 * \section confnix Configuring the Nut/OS Development for Linux.
 *
 * Linux users are relieved of the burden choosing a compiler, but
 * the installation is a bit different from the dumb click and
 * clack being required under Windows.
 *
 * There is no all round packet like WinAVR, you need collect all
 * required parts first. These are
 *
 * \li avr-binutils
 * \li avr-gcc
 * \li avr-gcc-c++
 * \li avr-libc
 * \li avr-libc-docs
 * \li uisp
 * \li ethernut
 *
 * The next problem will arise, if your Linux system doesn't provide
 * rpm support. The following steps had been tested on Redhat 9 and
 * should work under Suse too. Different steps may be required for
 * Debian.
 *
 * To install the compiler, change to the directory where all packets
 * have been downloaded to. When using the Ethernut Starter Kit, they
 * are located on the CDROM. Then install the rpms. Note, that the
 * filenames may differ, if you got newer releases.
 *
 * \code cd /cdrom/gnu-c/gcc_linux/
 * rpm -Uvh \
 * avr-binutils-2.13.90.030512-1.i386.rpm \
 * avr-gcc-3.2.90.20030512-1.i386.rpm \
 * avr-gcc-c++-3.2.90.20030512-1.i386.rpm \
 * avr-libc-20030512cvs-1.i386.rpm \
 * avr-libc-docs-20030512cvs-1.i386.rpm \endcode
 *
 * If not done previously you may install uisp now.
 *
 * \code cd /cdrom/tools/linux/
 * tar -zxvf uisp-20030618.tar.gz -C ~/
 * cd ~/uisp-20030618/
 * ./configure
 * make
 * make install \endcode
 *
 * Finally install the Nut/OS and Nut/Net sources.
 *
 * \code cd /cdrom/ethernut/unix/
 * tar -zxvf ethernut-3.3.2.tar.gz -C ~/
 * cd ~/ethernut-3.3.2/nut/
 * ./configure \endcode
 *
 * The configure script will guide you through the final
 * steps, selecting the right CPU and the type of your
 * programming adapter.
 *
 * You may now rebuild the Nut/OS libraries by entering
 *
 * \code make clean
 * make install \endcode
 *
 * This step should be passed without any errors or even
 * warning. If not, you may have used the wrong compiler or
 * library version.
 *
 * Now you can check, if you are able to compile the http
 * daemon sample and upload the resulting binary to your
 * Ethernut board.
 *
 * \code cd app/httpd/
 * make burn \endcode
 *
 *
 * \section confwin Configuring the Nut/OS Development for Windows.
 *
 * After having choosen the compiler, you are ready to configure the
 * development environment. You should have installed your compiler
 * and Nut/OS. Open a command line window (DOS window) and change to
 * the Nut/OS installation directory.
 *
 * Now you need to set the correct path to the subdirectory, where all
 * the binaries of your compiler are installed.
 *
 * For ICCAVR you may enter something like
 *
 * \code SET PATH=C:\icc\bin;%PATH% \endcode
 *
 * The typical WinAVR installation may require
 *
 * \code SET PATH=C:\WinAVR\bin;C:\WinAVR\utils\bin;%PATH% \endcode
 *
 * Next enter
 *
 * \code nutconf \endcode
 *
 * which will start the configuration tool. Again select the right
 * compiler, the type of CPU and the programming adapter you are
 * using and press the Configure button. Confirm to rebuild the 
 * libraries. Nut/OS comes with ready build libraries, but when
 * using ICCAVR, these libraries need to be copied to the compiler's
 * lib directory. For AVRGCC there's no need to rebuild them, but
 * it didn't hurt.
 *
 * If you want to change the compiler or in case you modified
 * any part of the system, you can call nutconf again later to
 * change your settings and create a new library version.
 *
 * \section iccide Using the ImageCraft IDE.
 *
 * The ImageCraft IDE should be used for your application
 * code only. Compiling the Nut/OS libraries requires a command
 * line environment (see next section).
 *
 * Executing nutconf as described above copies all Nut/OS
 * libraries to the ImageCraft library directory.
 *
 * Before creating Nut/OS applications, you have to enter
 * some special settings in the ImageCraft Project. On the
 * first page of the Compiler Options Dialog you need to
 * add the Nut/OS include file path. Note, that the path
 * of your ImageCraft directory may differ.
 *
 * \code ..\..\include\;C:\icc\include\ \endcode
 *
 * On the second page the macro define
 *
 * \code  _MCU_enhanced \endcode
 *
 * has to be added if you are developing for the ATmega128.
 *
 * On the last page you must add the following additional libs.
 *
 * \code nutpro nutnet nutfs nutos nutdev nutcrt \endcode
 *
 * On the same page enter
 *
 * \code -ucrtnut.o c:\icc\lib\nutinit.o \endcode
 *
 * in the field named Other Options. Again, your path to the 
 * ImageCraft directory may differ. Please refer to the ICCAVR 
 * Online Manuals for further assistance.
 *
 * \section iccenv Command Line Environment for ICCAVR
 *
 * In case you avoid IDEs in general or if you want to make
 * your own modifications to Nut/OS libraries, then you must use
 * a shell, also known as the DOS window or command line.
 *
 * Change to the Nut/OS installation directory and make sure, 
 * that your PATH includes the ICCAVR bin directory.
 *
 * To rebuild the complete library, enter
 *
 * \code make clean \endcode
 *
 * followed by
 *
 * \code make install \endcode
 *
 * All Nut/OS and Nut/Net libraries should compile and link without 
 * problem and will be copied to the Nut/OS lib directory. The
 * configure tool will then copy these libraries to the ImageCraft
 * lib directory.
 *
 * Get yourself familiar with the GNU make utility.
 *
 * Most applications written for AVR-GCC will not run properly 
 * when compiled by ICCAVR. Specifically the macro PSTR() will not 
 * work with ICCAVR. For porting, refer to the samples in subdirectory 
 * appicc.
 *
 * \section gccenv Command Line Environment for WinAVR
 *
 * Open a shell and change to the directory, which contains your
 * application source code. Make sure, that your PATH includes the 
 * AVRGCC bin directory. WinAVR users must include two directories 
 * in their path.
 *
 * \code SET PATH=C:\WinAVR\bin;C:\WinAVR\utils\bin;%PATH% \endcode
 *
 * To build you application's hex file, simply enter
 *
 * \code make \endcode
 *
 * If you are using uisp for uploading the hex file to the target
 * system, you can enter
 *
 * \code make burn \endcode
 *
 * This will build your application and, if successful, automatically
 * program your target.
 * 
 * To rebuild the complete Nut/OS library, change to the Nut/OS 
 * installation directory and enter
 *
 * \code make clean \endcode
 *
 * followed by
 *
 * \code make install \endcode
 *
 * If successful, the new libraries will be copied to the Nut/OS lib
 * directory.
 */

/*!
 * \page contribs How to contribute.
 *
 * Contributions to Nut/OS are most welcome. If you want to, please
 * try to follow some rules to keep the code consistent and easy to
 * read.
 *
 * - Use K&R indentation style. Use "indent -kr".
 * - Tab size is 8. This is very important.
 * - Try to follow the Doxygen inline documentation style. Otherwise your
 *   changes will not appear in this manual.
 * - Try to make sure that your code is working with all supported compilers.
 * - Compiler specific variations should be defined in compiler.h.
 * - Use BSD types in types.h.
 * - If you want to replace existing library functions, place them in the
 *   mod directory. This avoids breaking existing code.
 *
 * No one will reject your code, if you don't follow these rules. However,
 * it may take more time until it appears in an official release.
 */


/*!
 * \page copyleft Copyright Statement
 *
 * Nut/OS and Nut/Net are
 *
 * Copyright (C) 2000-2003 by egnite Software GmbH. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgement:
 *
 *    This product includes software developed by egnite Software GmbH
 *    and its contributors.
 *
 * THIS SOFTWARE IS PROVIDED BY EGNITE SOFTWARE GMBH AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL EGNITE
 * SOFTWARE GMBH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * -
 * Portions Copyright (C) 2000 David J. Hudson <dave@humbug.demon.co.uk>
 *
 * This file is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You can redistribute this file and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software Foundation;
 * either version 2 of the License, or (at your discretion) any later version.
 * See the accompanying file "copying-gpl.txt" for more details.
 *
 * As a special exception to the GPL, permission is granted for additional
 * uses of the text contained in this file.
 * -
 * Portions Copyright (c) 1983, 1993 by
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 * \subsection gnuexc Special Exception To the GNU General Public License For Liquorice
 *
 * <b>Preamble</b>
 *
 * Whilst the GNU General Public License is generally suitable for most
 * operating system applications within a workstation or server environment,
 * it presents certain obstacles that prevent its wide acceptance within
 * many embedded application fields. In particular the requirements that
 * prevent the linking of software licensed under the GPL with software
 * that is not licensed under the GPL present a serious problem to many
 * would-be users who for various reasons are unable to comply with this.
 *
 * With this in mind, Liquorice is released with the a special exception
 * to the GNU Public License that permits some additional uses of the
 * software.
 *
 * <b>Special Exception</b>
 *
 * If you choose to link software from Liquorice with other files to
 * produce an executable, this does not by itself cause the resulting
 * executable to be covered by the GNU General Public License. Your use
 * of the executable is in no way restricted on account of linking the
 * Liquorice code with it.
 *
 * This exception does not however invalidate any other reason why the
 * executable file might be covered by the GNU General Public License.
 *
 * This exception applies only to the code released by David J. Hudson
 * and any other identified copyright holder under the name Liquorice.
 * If you copy other code that is released by its copyright holder under
 * the GNU General Public License into a copy of Liquorice, as the GNU
 * General Public License permits, then this exception does not apply to
 * the code that you add in this way. To avoid misleading anyone as to
 * the status of such modified files, you must delete references to this
 * exception notice from them.
 *
 * If you write modifications of your own for Liquorice, it is your
 * choice whether to permit this exception to apply to your modifications.
 * If you do not wish this, delete references to this exception notice
 * from the affected files.
 */

/* ====================================== Nut/OS ==================================== */
/*!
 * \defgroup xgNutOS Nut/OS API
 *
 * \brief
 * Ethernut Operating System API.
 *
 * Nut/OS is a small real time operating system aimed at 8-bit CPUs.
 *
 * It supports the following features:
 *    - Corporative multi-threading
 *    - Synchronization mechanisms
 *    - Dynamic memory management
 *    - Asynchronous timers
 *    - Serial port character I/O
 *
 * A reasonably large hardware resource might be:
 *    - 0.5 kBytes RAM
 *    - 8 kBytes ROM
 *    - 1 MIPS CPU speed
 *
 */
/*@{*/

/*!
 * \defgroup xgNutInit System Initialization
 * \brief Nut/OS initialization.
 */

/*!
 * \defgroup xgThread Thread Management
 * \anchor xrThread
 * \brief Coperative multi-threading support.
 *
 * Typically Nut/OS is at its most useful where there are several
 * concurrent tasks that need to be undertaken at the same time.
 * To support this requirement, Nut/OS offers some kind of light
 * processes called threads. In this context a thread is a sequence
 * of executing software that can be considered to be logically
 * independent from other software that is running on the same CPU.
 *
 * All threads are executing in the same address space using the
 * same hardware resources, which significantly reduces task switching
 * overhead. Therefore it is important to stop them from causing
 * each other problems. This is particularly an issue where two or
 * more threads need to share a resources like memory locations or
 * peripheral devices.
 *
 * The system works on the principle that the most urgent thread
 * always runs. One exception to this is if a CPU interrupt arrives
 * and the interrupt has not been disabled. Each thread has a
 * priority which is used to determine how urgent it is. This
 * priority ranges from 0 to 255, with the lowest value indicating
 * the most urgent.
 *
 * Nut/OS implements cooperative multithreading. That means,
 * that threads are not bound to a fixed timeslice. Unless
 * they are waiting for specific event or explicitely yielding
 * the CPU, they can rely on not being stopped unexpectedly.
 * However, they may be interrupted by hardware interrupt
 * signals. In opposite to pre-emptive multithreading,
 * coorperative multithreading simplifies resource sharing
 * and results in faster and smaller code.
 *
 */
/*@{*/
/*!
 * \defgroup xgThreadState Thread States
 * \brief Thread operating states.
 */
/*@}*/

/*!
 * \defgroup xgEvent Event Management
 * \brief Thread synchronization support.
 *
 * Threads may wait for events from other threads or
 * interrupts or may post or broadcast events to
 * other threads.
 *
 * Waiting threads line up in priority ordered queues,
 * so more than one thread may wait for the same event.
 *
 * Events are posted to a waiting queue, moving the
 * \ref xrThread "thread" from waiting (sleeping) state to ready-to-run
 * state. A running thread may also broadcast an event
 * to a specified queue, waking up all threads on that
 * queue.
 *
 * Usually a woken up thread takes over the CPU, if it's
 * priority is equal or higher than the currently running
 * thread. However, events can be posted asynchronously,
 * in which case the posting thread continues to run.
 * Interrupt routines must always post events asynchronously.
 *
 * A waiting queue is a simple linked list of waiting
 * threads.
 *
 * 
 */

/*!
 * \defgroup xgMutex Recursive Mutex 
 * \brief Thread synchronization support.
 *
 * In addition to posting and waiting for events, Threads
 * can use the provided recursive mutex funxtions to assert
 * mutual access to shared data structures.
 *
 * A recursive mutex is a mutex that can be locked several
 * times by the thread that already owns the mutex.
 * 
 */

/*!
 * \defgroup xgSemaphore Semaphore
 * \brief Thread synchronization support.
 *
 * In addition to posting and waiting for events, Threads
 * can use the provided semaphore funxtions to handle a pool
 * of shared resources.
 * 
 */
 
 
/*!
 * \defgroup xgHeap Heap Management
 * \brief Dynamic memory management.
 *
 * Dynamic memory allocations are made from the heap. The heap is a
 * global resource containing all of the free memory in the system.
 * The heap is handled as a linked list of unused blocks of memory,
 * the so called free-list.
 *
 * The heap manager uses best fit, address ordered algorithm
 * to keep the free-list as unfragmented as possible. This strategy
 * is intended to ensure that more useful allocations can be made.
 * We end up with relatively few large free blocks rather than lots
 * of small ones.
 */

/*!
 * \defgroup xgBankMem Banked Memory Management
 * \brief Banked RAM support.
 *
 * Even with a hardware decoder like the one used on the Medianut Board, 
 * streaming MP3 data in realtime from a TCP/IP network to the decoder 
 * requires some special techniques to make it work on a tiny 8 bit system.
 * 
 * The key to success is avoidance of data copying. Usually data streams 
 * are moved from the Ethernet Controller to the Ethernet's driver buffer, 
 * then moved to the TCP buffer, again moved to the application buffer and 
 * finally from the application buffer to the MP3 decoder buffer. Some 
 * systems may use additional steps. Nut/OS tries to avoid these copies. In 
 * extreme, the data may be moved directly from the Ethernet controller to 
 * the MP3 controller. In reality this will fail, because TCP isn't realtime, 
 * but playing MP3 is. So at least one buffer stage is required to compensate 
 * the non deterministic arrival of TCP data. Each packet received is moved 
 * from the Ethernet controller into a so called NETBUF. Each NETBUF is 
 * added to a connection specific queue until the application request data 
 * from the connection. For portability reasons and to keep things simple, 
 * the application provides a buffer and calls NutTcpReceive() to get that 
 * buffer filled with application data out of the queued NETBUFs. This is 
 * another copy, but frees the application from dealing with system specific 
 * NETBUF structures.
 *
 * The smart part is, that Nut/OS offers a special buffer management to avoid 
 * the final copy into the decoder buffer and that the Nut/OS MP3 decoder 
 * driver makes use of this buffer management. As stated, normally the 
 * application buffer is filled by some kind of read statement (first copy) 
 * and transfered to the driver by some kind of write statement (second copy). 
 *
 * When using the segmented memory management, the application will query the 
 * driver for buffer space first and then pass this buffer to the TCP read 
 * routine. This way the TCP read routine will directly fill the buffer of the 
 * decoder driver. When this has been done, the application commits the buffer 
 * filled and requests a new one and so on.
 *
 * Finally the segmented memory mamagement API can not only handle a continuos 
 * memory space, but also one that is divided into several segments. This is 
 * usefull with banked memory hardware provided by Ethernut 2 boards.
 */

/*!
 * \defgroup xgIO I/O Management
 *
 * \brief Input and output device functions.
 */

/*@{*/

/*!
 * \defgroup xgDevice Device I/O
 *
 * \brief Input and output device functions.
 */

/*@}*/

/*!
 * \defgroup xgTimer Timer Management
 * \brief Asynchronous timer support.
 * 
 * The timer management provides functions to start and stop
 * asynchronous timers, determine the CPU speed and let a
 * thread give up the CPU for a specified time period.
 */


/*@}*/

/* ====================================== Nut/Net ==================================== */
/*!
 * \defgroup xgNutNet Nut/Net API
 *
 * \brief Nut/Net TCP/IP Stack.
 *
 * The Nut/Net networking code is designed in a fairly fundamentally
 * different way to most IP stacks. Most systems rely on polling
 * information out of the network code, which has to buffer the
 * information until it is requested.
 *
 * The Nut/Net IP stack however uses a dataflow architecture where data
 * is pushed up the protocol layers immediately after data has
 * been received. The data does not get buffered unless one of the layers
 * makes a policy decision to do so. Generally data will be pushed all
 * the way up to the socket API.
 *
 * In a small system this design reduces memory requirements, eliminates
 * expensive queueing and threading operations.
 */
/*@{*/

/*!
 * \defgroup xgSocket Socket API
 */
/*@{*/

/*!
 * \defgroup xgTcpSocket TCP Sockets
 * \brief TCP sockets.
 */

/*!
 * \defgroup xgUdpSocket UDP Sockets
 * \brief UDP sockets.
 *
 * Nut/Net supports connectionless UDP sockets only.
 */

/*@}*/

/*!
 * \defgroup xgProtos Protocols
 */
/*@{*/

/*!
 * \defgroup xgPro User Protocols
 * \brief TCP/IP and UDP applications.
 */
/*@{*/

/*!
 * \defgroup xgDHCPC DHCP
 * \brief Dynamic host configuration protocol.
 */

/*!
 * \defgroup xgFTPD FTP
 * \brief File transfer protocol.
 */

/*!
 * \defgroup xgHTTPD HTTP
 * \brief Hypertext transfer protocol.
 */

/*!
 * \defgroup xgDNS DNS
 * \brief Domain name service protocol.
 */

/*@}*/

/*!
 * \defgroup xgTCP TCP
 * \brief RFC 793 Transmission Control Protocol
 *
 * TCP provides reliable, in-sequence delivery of a full-duplex 
 * stream of octets. It is used by applications which need a
 * reliable, connection-oriented data transport.
 */

/*!
 * \defgroup xgUDP UDP
 * \brief RFC 768 user datagram protocol.
 *
 * UDP only provides checksumming of data and multiplexing by port
 * number. Therefore, an application program must deal directly with 
 * end-to-end communication problems like retransmission, flow
 * control etc., if required.
 */

/*!
 * \defgroup xgIP IP
 * \brief RFC 791 Internet protocol version 4.
 *
 * \todo Configurable checksum calculation for incoming datagrams.
 */

/*!
 * \defgroup xgICMP ICMP
 * \brief RFC 792 Internet Control Message Protocol.
 *
 * Provides routing, diagnostic and error functionality for IP.
 * Although ICMP messages are encapsulated within IP datagrams, 
 * ICMP processing is considered to be part of the IP layer.
 */

/*!
 * \defgroup xgARP ARP
 * \brief RFC 826 address resolution protocol.
 *
 * ARP is used to map IP addresses to hardware addresses.
 * Each network interface of Nut/Net keeps its own mapping
 * table.
 *
 * When an IP packet has to be sent out, IP needs the
 * hardware address to pass it to the Ethernet layer.
 * If the mapping is not in the ARP cache, an Ethernet
 * broadcast packet is sent to the local network
 * requesting the physical hardware address for the
 * given IP address.
 *
 * \todo Add functions to manually add or remove ARP entries.
 * \todo Add function to query ARP tables.
 */

/*!
 * \defgroup xgEthernet Ethernet
 * \brief RFC 894 IP over Ethernet.
 */

/*!
 * \defgroup xgPppProt PPP
 * \brief Point to point protocol.
 */
/*@{*/

/*!
 * \defgroup xgLCP LCP
 * \brief Link control protocol.
 */

/*!
 * \defgroup xgPAP PAP
 * \brief Password authentication protocol.
 */

/*!
 * \defgroup xgIPCP IPCP
 * \brief IP control protocol.
 */

/*!
 * \defgroup xgPPP PPP
 * \brief PPP Driver.
 */

/*!
 * \defgroup xgAHDLC AHDLC
 * \brief AHDLC Driver.
 *
 * This driver has not been published yet. It will contain a modified UART
 * driver with some speed optimizations like table driven FCS calculation.
 * It will also implement simple modem handshaking (RTS, CTS and DTR).
 */


/*@}*/


/*@}*/

/*@}*/

/* ====================================== File System ==================================== */
/*!
 * \defgroup xgFileSystem File System API.
 */
/*@{*/

/*!
 * \defgroup xgurom Micro-ROM File System.
 * \brief Simple program space file system.
 */
/*@}*/
/* ======================================================================================= */

/* =================================== Device Driver API ================================= */
/*!
 * \defgroup xgDriver Device Driver API.
 *
 * \brief Input and output device functions.
 */
/*@{*/

/*!
 * \defgroup xgHardware Hardware Layout.
 * \brief Definitions of I/O ports.
 *
 * Each add-on board should provide its own include file.
 */
/*@{*/

/*!
 * \defgroup xgEthernutCfg Ethernut Hardware.
 * \brief Ethernut internal I/O port usage.
 *
 */

/*!
 * \defgroup xgMedianutCfg Medianut Hardware.
 * \brief Ports used by the Medianut MP3 Add-On.
 *
 * Medianut is an add-on board and can be attached to the Ethernut
 * expansion port. It contains a VS1001K MP3 decoder, a LCD interface 
 * and an infrared receiver.
 */

/*!
 * \defgroup xgModemCfg Modem Control.
 * \brief Modem hardware dependencies.
 *
 * Specification of RS232 handshake lines.
 */

/*@}*/

/*!
 * \defgroup xgDevSerial Serial communication devices.
 * \brief Drivers for serial communication.
 *
 * Nut/OS currently supports two types of devices for
 * serial communication:
 *
 * - \ref xrUartAvr "AVR UART devices", the AVR on-chip UARTs.
 * - \ref xrUartSpi "SPI UART devices", additional AVR chips used
 * with add-on boards.
 */
/*@{*/

/*!
 * \defgroup xgUartAvr AVR UART Device Driver
 * \anchor xrUartAvr
 * \brief Device driver for ATmega On-Chip UART.
 *
 * This device driver writes data to and reads data from the UART on 
 * the ATmega128/103 chip. Both, input and output data is buffered and 
 * send resp. transmitted by interrupt routines.
 *
 * Not all ioctl() function are fully implemented. New applications
 * should use the \ref xrUsart "USART" device driver.
 *
 */

/*@{*/
/*!
 * \defgroup xgUartDev ATmega On-Chip UART Devices
 * \brief UART Device Structures.
 *
 */
/*@}*/

/*!
 * \defgroup xgUsart USART Device Driver
 * \anchor xrUsart
 * \brief Universal synchronous/asynchronous receiver/transmitter device driver.
 *
 * The USART device driver implements buffered, interrupt controlled
 * serial communication. In opposite to the 
 * \ref xrUartAvr "AVR UART Device Driver"
 * it supports software and hardware handshake, 9-bit communication, 
 * half duplex and synchronous operation.
 *
 * The driver's code is devided into a general part and a hardware 
 * dependant part, which simplifies porting it to different USART chips.
 * The \ref xrUsartAvr "AVR USART Devices" provide support for the
 * ATmega128/103 on-chip USARTs.
 */

/*@{*/
/*!
 * \defgroup xgUsartAvr AVR USART Devices
 * \anchor xrUsartAvr
 * \brief AVR USART hardware dependant implementation.
 *
 * A pointer to \ref devUsartAvr0 or \ref devUsartAvr1 must be passed to 
 * NutRegisterDevice() to bind the corresponding device driver to the 
 * Nut/OS kernel.
 * \code
 * NutRegisterDevice(&devUsartAvr0, 0, 0);
 * fp = fopen("uart0", "r+");
 * fprintf("Hello world!\n");
 * \endcode
 *
 * The AVR USART devices make use of the hardware independant
 * \ref xrUsart "USART Device Driver"
 */
/*@}*/

/*!
 * \defgroup xgDebugDev AVR UART Debug Device Driver
 * \brief Debug output driver for ATmega On-Chip UART.
 *
 * This stream device driver writes data to the internal UART of
 * the ATmega128/103 chip. The output is unbuffered and uses
 * polling. Therefore it can be used for standard I/O output
 * even within interrupt routines.
 */

/*@{*/
/*!
 * \defgroup xgDebugDev0 UART0 Debug Devices
 * \brief UART0 debug device structure.
 *
 */
/*!
 * \defgroup xgDebugDev1 UART1 Debug Devices
 * \brief UART1 debug device structure.
 *
 */
/*@}*/

/*!
 * \defgroup xgUartSpi SPI UART Device Driver
 * \anchor xrUartSpi
 * \brief Serial communication device driver.
 *
 * This stream device driver writes data to and reads data
 * from an external device via the SPI bus. Both, input and
 * output data bytes are buffered and send resp. transmitted 
 * by interrupt routines.
 *
 * Up to eight additional UARTs are supported. All external 
 * AVRs, for which the AT90S2313 is a good low cost choice, 
 * are connected to the SPI of the main CPU.
 *
 */

/*@{*/
/*!
 * \defgroup xgUartsDev SPI UART Device
 */
/*@}*/

/*!
 * \defgroup xgUARTIOCTL UART I/O Control Functions
 */
/*@{*/

/*!
 * \defgroup xgUARTStatus UART Status
 */
/*@}*/

/*@}*/

/*!
 * \defgroup xgDevNetwork Network device drivers.
 * \brief Ethernet controller drivers.
 */
/*@{*/

/*!
 * \defgroup xgNicRtl Realtek 8019AS device driver
 * \brief Ethernet device driver.
 *
 * The RTL8019AS chip is used on the Ethernut 1 board.
 */
/*@{*/
/*!
 * \defgroup xgEth0Dev Device eth0
 * \brief Realtek 8019AS Ethernet device
 */
/*@}*/

/*!
 * \defgroup xgNicLanc111 LAN91C111 device driver
 * \brief Ethernet device driver.
 *
 * The LAN91C111 chip is used on the Ethernut 2 board.
 */
/*@{*/
/*!
 * \defgroup xgSmscRegs LAN91C111 registers
 * \brief SMSC LAN91C111 register definitions.
 */
/*!
 * \defgroup xgSmscDev Device eth0
 * \brief SMSC LAN91C111 Ethernet device
 */
/*@}*/

/*!
 * \defgroup xgNicCs8900 CS8900 device driver
 * \brief Ethernet device driver.
 */
/*@{*/
/*!
 * \defgroup xgCs8900Dev Device eth0
 * \brief CS8900 Ethernet device
 */
/*@}*/


/*!
 * \defgroup xgnetbuf Network Buffer
 * \brief Network buffer support.
 *
 * The network buffer handling is designed to make life easy when it
 * comes to handling ISO-layered communications. By this we're thinking
 * about communications structures that are hierarchically organized.
 *
 * The idea is that network buffer structures are allocated every time a new
 * packet is either received or ready for sending. The various fields
 * of the network buffer are then handled by matching layers within the
 * appropriate protocol stack.
 *
 * Linked list of NETBUF structures:
 *
 * \dot
 * digraph netbufs {
 *   bgcolor="#fafafa";
 *   size="7,3"; ratio=compress;
 *   node[fontname=Helvetica];
 *   NETBUF[shape=plaintext, label="NETBUF Structures"];
 *   NETBUF -> netb0[style=dotted, arrowhead=none];
 *   NETBUF -> netb1[style=dotted, arrowhead=none];
 *   {
 *     rank=same;
 *     netb0[shape=record, label="<nx>nb_next|nb_flags|{nb_dl|{sz|<dl>vp}}|{nb_nw|{sz|<nw>vp}}|{nb_tp|{sz|<tp>vp}}|{nb_ap|{sz|<ap>vp}}"];
 *     netb1[shape=record, label="<nx>nb_next|nb_flags|{nb_dl|{sz|<dl>vp}}|{nb_nw|{sz|<nw>vp}}|{nb_tp|{sz|<tp>vp}}|{nb_ap|{sz|<ap>vp}}"];
 *     netnul[shape=record, label="NULL"];
 *   }
 *   {
 *     rank=same;
 *     heap0[shape=record, label="<dl>datalink|<nw>network|<tp>transport|<ap>application"];
 *     heap1[shape=record, label="<dl>datalink|<nw>network|<tp>transport|<ap>application"];
 *   }
 *   netb0:dl -> heap0:dl;
 *   netb0:nw -> heap0:nw;
 *   netb0:tp -> heap0:tp;
 *   netb0:ap -> heap0:ap;
 *   netb1:dl -> heap1:dl;
 *   netb1:nw -> heap1:nw;
 *   netb1:tp -> heap1:tp;
 *   netb1:ap -> heap1:ap;
 *   netb0:nx -> netb1:nx -> netnul;
 *   DATABUF[shape=plaintext, label="Data Buffers"];
 *   heap0 -> DATABUF[style=dotted, arrowtail=none, dir=back];
 *   heap1 -> DATABUF[style=dotted, arrowtail=none, dir=back];
 * }
 * \enddot
 */

/*!
 * \defgroup xgSoStream Network Stream Device Driver
 * \brief Virtual TCP socket stream device.
 *
 * These function are deprecated for new applications. Use C stdio.
 */

/*@}*/

/*!
 * \defgroup xgDevSound Sound device drivers.
 * \brief MP3 harware support.
 */
/*@{*/

/*!
 * \defgroup xgVs1001 VS1001K device driver.
 * \brief MP3 decoder driver.
 */
/*@}*/

/*!
 * \defgroup xgDevDisplay Display device drivers.
 * \brief LCD/VFD hardware support.
 */
/*@{*/

/*!
 * \defgroup xgTerminal Terminal Emulator.
 * \brief Virtual terminal emulator.
 *
 * The virtual terminal driver allows to use a LC or VF display
 * for standard I/O. It supports VT52 control codes.
 */

/*!
 * \defgroup xgDisplay LC/VF Display Driver.
 */
/*@}*/



/*! 
 * \defgroup xgIrqReg Interrupt Management
 * \brief Interrupt registration and handling.
 */

/*! 
 * \defgroup xgSpiDigIo SPI Digital I/O
 * \brief SPI controlled digital input and output ports.
 *
 * This simple driver supports digital I/O ports like 
 * relay outputs and optocoupler inputs.
 */

/*! 
 * \defgroup xgSpiFlash SPI Flash Devices
 * \brief Programs SPI attached flash devices.
 *
 * When AVR CPUs are attached to the SPI, then the
 * routines in this module can be used to write
 * to the flash ROM of these devices.
 */

/*@}*/

/*!
 * \defgroup xgCrt C Runtime Library.
 * \brief Complementary runtime support.
 *
 * Normal C language runtime libraries are too large for small 
 * embedded systems and many functions require an underlying 
 * operating system. Compilers for the AVR provide a limited 
 * subset only, which do not include sufficient device support.
 *
 * Nut/OS includes its own runtime library. When linked with an 
 * application, this library partly overrides the standard library 
 * which comes with your compiler.
 *
 * \warning Using these functions requires to link nutcrt or nutcrtf
 *          before the compiler's standard libraries.
 */

/*@{*/

/*!
 * \defgroup xgCrtStdio Standard I/O
 * \brief Standard stream interface to Nut/OS devices. 
 *
 * \code #include <stdio.h> \endcode
 *
 * In contrast to the standard, Nut/OS streams do not maintain there 
 * own buffers. Any input or output buffering is done in the device 
 * driver.
 *
 * Nut/OS will not associate the standard streams stdin, stdout and
 * stderr to a device when starting the application. Instead, freopen() 
 * can be used by the application to redirect any of these stream to any 
 * previously opened file, device or connected socket.
 *
 * As an extension to the standard, many function come in an additional
 * flavour with \c _P appended to their name. These functions accept 
 * specific parameters pointing into program space.
 * 
 * Output Call Graph
 * \dot
 * digraph outchain {
 *     bgcolor="#fafafa";
 *     node[fontname=Helvetica, fontsize=10];
 *     printf[URL="\ref printf"];
 *     printf_P[URL="\ref printf_P"];
 *     _putf[URL="\ref _putf"];
 *     putc[URL="\ref putc"];
 *     putchar[URL="\ref putchar"];
 *     puts[URL="\ref puts"];
 *     fputc[URL="\ref fputc"];
 *     fputs[URL="\ref fputs"];
 *     fputs_P[URL="\ref fputs_P"];
 *     fprintf[URL="\ref fprintf"];
 *     fprintf_P[URL="\ref fprintf_P"];
 *     fwrite[URL="\ref fwrite"];
 *     fwrite_P[URL="\ref fwrite_P"];
 *     vfprintf[URL="\ref vfprintf"];
 *     vfprintf_P[URL="\ref vfprintf_P"];
 *     _write[URL="\ref _write"];
 *     _write_P[URL="\ref _write_P"];
 *     dev_write[URL="\ref _NUTDEVICE::dev_write"];
 *     putc -> fputc;
 *     putchar -> fputc;
 *     puts -> fputs;
 *     puts -> fputc;
 *     puts_P -> fputs_P;
 *     puts_P -> fputc;
 *     printf -> vfprintf;
 *     printf_P -> vfprintf_P;
 *     fprintf -> vfprintf;
 *     fprintf_P -> vfprintf_P;
 *     fwrite -> _write;
 *     fputc -> _write;
 *     fputs -> _write;
 *     fputs_P -> _write_P;
 *     fwrite_P -> _write_P;
 *     vfprintf -> _putf;
 *     vfprintf_P -> _putf;
 *     _putf -> _write;
 *     _write -> dev_write;
 *     _write_P -> dev_write_P;
 * }
 * \enddot
 * 
 * Input Call Graph
 * \dot
 * digraph inchain {
 *     bgcolor="#fafafa";
 *     node[fontname=Helvetica, fontsize=10];
 *     scanf[URL="\ref scanf"];
 *     getchar[URL="\ref getchar"];
 *     getc[URL="\ref getc"];
 *     gets[URL="\ref gets"];
 *     _getf[URL="\ref _getf"];
 *     fgetc[URL="\ref fgetc"];
 *     fgets[URL="\ref fgets"];
 *     fread[URL="\ref fread"];
 *     fscanf[URL="\ref fscanf"];
 *     fscanf_P[URL="\ref fscanf_P"];
 *     vfscanf[URL="\ref vfscanf"];
 *     vfscanf_P[URL="\ref vfscanf_P"];
 *     _read[URL="\ref _read"];
 *     dev_read[URL="\ref _NUTDEVICE::dev_read"];
 *     getchar -> fgetc;
 *     getc -> fgetc;
 *     gets -> fgetc;
 *     fgets -> fgetc;
 *     scanf -> vfscanf;
 *     scanf_P -> vfscanf_P;
 *     fscanf -> vfscanf;
 *     fscanf_P -> vfscanf_P;
 *     fread -> _read;
 *     fgetc -> _read;
 *     vfscanf -> _getf;
 *     vfscanf_P -> _getf;
 *     _getf -> _read;
 *     _read -> dev_read;
 * }
 * \enddot
 */

/*!
 * \defgroup xgCrtLowio Low Level I/O
 * \anchor xrCrtLowio
 * \brief Low level input and output operations.
 *
 * \code #include <io.h> \endcode
 * 
 * Standard C runtime file interface to Nut/OS devices.
 */

/*!
 * \defgroup xgCrtTime Time handling Functions
 * \brief Implements some standard C time functions.
 *
 * Use these functions to get the current time and convert, 
 * adjust, and store it as necessary. The current time is the system time. 
 *
 */

/*!
 * \defgroup xgCrtMisc Miscellaneous Functions
 * \brief Complementary runtime support.
 *
 *  
 */

/*@}*/

/*!
 * \defgroup xgMod Nut/OS Mods.
 * \brief Modifying system rotuines.
 *
 * The mod directory contains modified system modules. In order to
 * use these, link the object file before linking Nut/OS libraries.
 */

/*@{*/
/*!
 * \defgroup xgModHeap Guarded heap routines.
 * \brief Contributed by Peter Scandrett.
 */

/*@}*/

/* ======================================================================================= */

/*!
 * \defgroup xgUnixEmulation 
 * \brief Running Nut/OS Apps on a unix machine 
 *
 * Nut/OS can be compiled for a native unix target.
 *
 * The following hardware is currently emulated: RTC and UART.
 * A RTC clock is provided. All AVR UARTS are mapped to STDIO but this can configure
 * at app start-up using command line paramters. Syntax:
 * 
 * MyNutOSAPP.unix [-u0 deviceName] [-u1 deviceName] [-u2 deviceName]
 * 
 * The unix emulation provides a third uart for debugging purposes as devDebug2, devUsart2 and devUsartAvr2)
 * 
 */


